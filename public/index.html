<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Server Manager</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="index.css">
    <!-- Favicon: single correct path (public folder is served as root) -->
    <link rel="icon" href="/assets/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <div class="header-content">
                <h1 class="app-title">
                    <img src="assets/minecraft-icon.png" alt="Minecraft" class="title-icon">
                    Minecraft Server Manager
                </h1>
                <div class="header-actions">
                    <button class="btn create-btn" onclick="window.location.href='/create'">
                        <i class="fa fa-plus" aria-hidden="true"></i> Create Server
                    </button>
                    <button class="btn logout-btn" id="logoutBtn">
                        <i class="fa fa-right-from-bracket" aria-hidden="true"></i> Logout
                    </button>
                </div>
            </div>
        </header>

        <main class="app-main">
<div class="server-controls">
    <div class="server-stats">
        Servers: <span id="serverCount">0/3</span>
    </div>
    <div class="search-box">
        <input type="text" id="serverSearch" placeholder="Search servers...">
    </div>
</div>

           

            <div class="server-list" id="serverList">
                <!-- Servers will be loaded here dynamically -->
                <div class="empty-state">
                    <img src="assets/empty-server.png" alt="No servers" class="empty-icon">
                    <h2>No Minecraft Servers</h2>
                    <p>You don't have any servers yet. Click the button below to create your first server.</p>
                    <button class="btn primary-btn" onclick="window.location.href='/create'">
                        Create First Server
                    </button>
                </div>
            </div>


             <!-- Logs & Events panel: select a server to view its logs and recent events -->
            <div class="logs-panel">
                <label for="logServerSelect">Select server:</label>
                <select id="logServerSelect">
                    <option value="">-- Select server --</option>
                </select>
                <!-- <div class="logs-actions">
                    <button id="downloadLogsBtn" class="btn"> <i class="fa fa-download" aria-hidden="true"></i> Download Logs</button>
                    <button id="downloadEventsBtn" class="btn"> <i class="fa fa-download" aria-hidden="true"></i> Download Events</button>
                </div> -->
                <div class="console-wrapper logs-and-events">
                    <div class="logs-col">
                        <h4><i class="fa fa-file-alt" aria-hidden="true"></i> Logs</h4>
                        <pre id="serverLogs" class="server-logs">No server selected.</pre>
                    </div>
                    <div class="events-col">
                        <h4><i class="fa fa-exclamation-circle" aria-hidden="true"></i> Events</h4>
                        <pre id="serverEvents" class="server-events">No server selected.</pre>
                    </div>
                </div>

                <!-- Events popup (slide from right) -->
                <div id="eventsPopup" class="events-popup hidden" aria-hidden="true" role="dialog" aria-modal="false" aria-labelledby="eventsPopupLabel" tabindex="-1" inert>
                    <div class="events-popup-header">
                        <span id="eventsPopupLabel">Recent Events</span>
                        <button id="closeEventsPopup" class="btn small" aria-label="Close events panel"><i class="fa fa-times"></i></button>
                    </div>
                    <div id="eventsPopupList" class="events-popup-list" aria-live="polite">No events yet.</div>
                </div>
                <div class="events-toggle-group">
                    <button id="eventsPopupToggle" class="events-popup-toggle" title="Show recent events" aria-controls="eventsPopup" aria-expanded="false"><i class="fa fa-bell"></i></button>
                    <button id="eventsPopupDisableToggle" class="events-popup-disable" title="Disable pop-up events" aria-pressed="false" aria-label="Toggle pop-up events"><i class="fa fa-bell-slash"></i></button>
                </div>
            </div>

        </main>

        <footer class="app-footer">
            <p>Minecraft Server Manager v1.0 &copy; 2023</p>
        </footer>
    </div>

<script>
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            const token = localStorage.getItem('token');
            if (!token) {
                window.location.href = '/auth/login.html';
                return;
            }

            const response = await fetch('/api/projects', {
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (response.status === 401) {
                localStorage.removeItem('token');
                window.location.href = '/auth/login.html';
                return;
            }

            const data = await response.json();
            const serverList = document.getElementById('serverList');
            const serverCount = document.getElementById('serverCount');
            
            // Serverlar sonini yangilash
            function escapeHTML(str) {
                return String(str).replace(/[&<>"']/g, function(m) {
                    return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[m];
                });
            }
            if (data.projects) {
                const count = Object.keys(data.projects).length;
                serverCount.textContent = `${count}/3`;
            }
            
            // Agar serverlar bo'lmasa yoki xato bo'lsa
            if (!data.success || !data.projects || Object.keys(data.projects).length === 0) {
                serverList.innerHTML = `
                    <div class="empty-state">
                        <img src="assets/empty-server.png" alt="No servers" class="empty-icon">
                        <h2>No Minecraft Servers</h2>
                        <p>You don't have any servers yet. Click the button below to create your first server.</p>
                        <button class="btn primary-btn" onclick="window.location.href='/create'">
                            Create First Server
                        </button>
                    </div>
                `;
                return;
            }

            // Serverlarni chiqarish
            serverList.innerHTML = '';
            for (const [id, server] of Object.entries(data.projects)) {
                const statusClass = server.status === 'running' ? 'status-running' : 'status-stopped';
                const statusText = server.status === 'running' ? 'Running' : 'Stopped';
                
                const serverCard = document.createElement('div');
                serverCard.className = 'server-card';
                serverCard.id = `server-${id}`;
                serverCard.innerHTML = `
                    <div class="server-header">
                        <div class="server-type-badge ${server.type}">
                            ${server.type === 'java' ? 'Java' : 'Bedrock'}
                        </div>
                        <div class="server-status ${statusClass}">
                            <span class="status-indicator"></span>
                            ${escapeHTML(statusText)}
                        </div>
                    </div>
                    
                    <div class="server-details">
                        <div class="detail-row">
                            <span class="detail-label">ID:</span>
                            <span class="detail-value">${escapeHTML(id)}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Version:</span>
                            <span class="detail-value">${escapeHTML(server.version)}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Address:</span>
                            <span class="detail-value">${escapeHTML(server.host)}:${escapeHTML(server.port)}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Created:</span>
                            <span class="detail-value">${escapeHTML(new Date(server.createdAt).toLocaleDateString())}</span>
                        </div>
                    </div>
                    
                    <div class="server-actions">
                        <button class="btn action-btn start-btn" onclick="startServer('${id}')" ${server.status === 'running' ? 'disabled' : ''}>
                            <i class="fa fa-play btn-icon" aria-hidden="true"></i> Start
                        </button>
                        <button class="btn action-btn stop-btn" onclick="stopServer('${id}')" ${server.status === 'stopped' ? 'disabled' : ''}>
                            <i class="fa fa-stop btn-icon" aria-hidden="true"></i> Stop
                        </button>
                        <button class="btn action-btn delete-btn" onclick="deleteServer('${id}')">
                            <i class="fa fa-trash btn-icon" aria-hidden="true"></i> Delete
                        </button>
                    </div>
                `;
                serverList.appendChild(serverCard);

                // Also add to log select
                const logSelect = document.getElementById('logServerSelect');
                if (logSelect) {
                    const opt = document.createElement('option');
                    opt.value = id;
                    opt.textContent = `${id} (${escapeHTML(server.host)}:${escapeHTML(server.port)})`;
                    logSelect.appendChild(opt);
                }
            }

            // Health and admin controls (show raknet status and rebuild button for admins)
            (async function loadHealthAndAdmin() {
                try {
                    const token = localStorage.getItem('token');
                    if (!token) return; // not logged in

                    const [healthRes, verifyRes] = await Promise.all([
                        fetch('/api/health'),
                        fetch('/api/auth/verify', { headers: { 'Authorization': `Bearer ${token}` } })
                    ]);

                    const health = await healthRes.json();
                    const verify = await verifyRes.json();

                    // Add health info to header
                    const headerActions = document.querySelector('.header-actions');
                    if (headerActions) {
                        const statusEl = document.createElement('div');
                        statusEl.className = 'raknet-status';
                        statusEl.innerHTML = `<i class="fa ${health.raknet.installed ? 'fa-check-circle' : 'fa-times-circle'}" aria-hidden="true"></i> Raknet: ${health.raknet.installed ? 'OK' : 'Missing'}`;
                        headerActions.appendChild(statusEl);

                        if (verify.success && verify.isAdmin) {
                            const rebuildBtn = document.createElement('button');
                            rebuildBtn.className = 'btn rebuild-btn';
                            rebuildBtn.innerHTML = '<i class="fa fa-wrench" aria-hidden="true"></i> Rebuild raknet-native';
                            rebuildBtn.addEventListener('click', async () => {
                                rebuildBtn.disabled = true;
                                const originalText = rebuildBtn.innerHTML;
                                rebuildBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Rebuilding...';
                                try {
                                    const resp = await fetch('/api/admin/rebuild-raknet', { method: 'POST', headers: { 'Authorization': `Bearer ${token}` } });
                                    const data = await resp.json();
                                    if (data.success) {
                                        alert('Rebuild finished. Check server logs and /api/health. Output:\n' + (data.stdout || data.stderr || 'No output'));
                                    } else {
                                        alert('Rebuild failed: ' + (data.error || (data.stderr || 'Unknown')));
                                    }
                                } catch (err) {
                                    alert('Rebuild request failed: ' + err.message);
                                } finally {
                                    rebuildBtn.disabled = false;
                                    rebuildBtn.innerHTML = originalText;
                                }
                            });
                            headerActions.appendChild(rebuildBtn);

                            // Add view logs button
                            const viewLogsBtn = document.createElement('button');
                            viewLogsBtn.className = 'btn logs-btn';
                            viewLogsBtn.innerHTML = '<i class="fa fa-file-alt" aria-hidden="true"></i> View rebuild logs';
                            viewLogsBtn.addEventListener('click', async () => {
                                try {
                                    const r = await fetch('/api/admin/rebuild-logs', { headers: { 'Authorization': `Bearer ${token}` } });
                                    const j = await r.json();
                                    if (!j.success) {
                                        alert('No logs: ' + (j.error || 'unknown'));
                                        return;
                                    }
                                    const w = window.open('', '_blank');
                                    const txt = `Rebuild logs (latest):\nTimestamp: ${j.latest.timestamp}\nSuccess: ${j.latest.success}\n\nSTDOUT:\n${j.latest.stdout || ''}\n\nSTDERR:\n${j.latest.stderr || ''}\n\nError: ${j.latest.error || 'none'}`;
                                    w.document.body.style.whiteSpace = 'pre-wrap';
                                    w.document.title = 'Rebuild logs';
                                    w.document.body.textContent = txt;
                                } catch (err) {
                                    alert('Failed to fetch logs: ' + err.message);
                                }
                            });
                            headerActions.appendChild(viewLogsBtn);
                        }
                    }
                } catch (e) {
                    console.warn('Health/admin UI load failed:', e);
                }
            })();

        } catch (error) {
            console.error('Error loading servers:', error);
            showToast('Failed to load servers. Please try again.', 'error');
        }

        // Log & Events selection handling
        let logPollInterval = null;
        let eventsPollInterval = null;
        const logSelect = document.getElementById('logServerSelect');
        const serverLogs = document.getElementById('serverLogs');
        const serverEvents = document.getElementById('serverEvents');
        const downloadBtn = document.getElementById('downloadLogsBtn');
        const downloadEventsBtn = document.getElementById('downloadEventsBtn');

        function clearLogPoll() {
            if (logPollInterval) {
                clearInterval(logPollInterval);
                logPollInterval = null;
            }
        }
        function clearEventsPoll() {
            if (eventsPollInterval) {
                clearInterval(eventsPollInterval);
                eventsPollInterval = null;
            }
        }

        async function fetchAndRenderLogs(projectId) {
            if (!projectId) {
                serverLogs.textContent = 'No server selected.';
                return;
            }

            try {
                const token = localStorage.getItem('token');
                const res = await fetch(`/api/projects/${projectId}/logs?lines=500`, { headers: { 'Authorization': `Bearer ${token}` } });
                if (!res.ok) {
                    const j = await res.json().catch(() => ({}));
                    serverLogs.textContent = 'Failed to fetch logs: ' + (j.error || res.statusText);
                    return;
                }
                const j = await res.json();
                const text = (j.log && j.log.trim()) ? j.log : 'No logs yet.';
                serverLogs.textContent = text;
                serverLogs.scrollTop = serverLogs.scrollHeight;
            } catch (err) {
                serverLogs.textContent = 'Error fetching logs: ' + err.message;
            }
        }

        async function fetchAndRenderEvents(projectId) {
            if (!projectId) {
                if (serverEvents) serverEvents.textContent = 'No server selected.';
                return;
            }

            try {
                const token = localStorage.getItem('token');
                const res = await fetch(`/api/projects/${projectId}/events?lines=200`, { headers: { 'Authorization': `Bearer ${token}` } });
                if (!res.ok) {
                    const j = await res.json().catch(() => ({}));
                    if (serverEvents) serverEvents.textContent = 'Failed to fetch events: ' + (j.error || res.statusText);
                    // per user request: do NOT show error popups for non-lifecycle messages
                    return;
                }
                const j = await res.json();
                const rawText = (j.events && j.events.trim()) ? j.events : '';

                // Filter to only lifecycle events for the UI
                const lines = rawText.split(/\r?\n/).filter(Boolean);
                const lifecycleLines = lines.filter(line => isLifecycleEvent(line));

                // Normalize and dedupe consecutive identical lines to avoid repeats
                const normalized = lifecycleLines.map(normalizeEventLine).filter(Boolean);
                const deduped = normalized.filter((l, i, a) => i === 0 || l !== a[i-1]);
                const displayText = deduped.length ? deduped.join('\n') : 'No lifecycle events yet.';

                // Update events box (show only filtered/deduped lifecycle events)
                if (serverEvents) {
                    serverEvents.textContent = displayText;
                    serverEvents.scrollTop = serverEvents.scrollHeight;
                }

                // Show popup only for the latest lifecycle event (normalized)
                const lastLineRaw = deduped.slice(-1)[0] || '';
                const plainMsg = lastLineRaw.replace(/^.*?:\s*/, '');
                if (plainMsg && plainMsg !== lastSeenEvent) {
                    lastSeenEvent = plainMsg;
                    showEventsPopup(plainMsg, { noTimestamp: true });
                }

            } catch (err) {
                if (serverEvents) serverEvents.textContent = 'Error fetching events: ' + err.message;
                // Do not show error popups per user preference
            }
        }

        // Small popup helper behavior
        let lastSeenEvent = '';
        const eventsPopup = document.getElementById('eventsPopup');
        const eventsPopupList = document.getElementById('eventsPopupList');
        const eventsPopupToggle = document.getElementById('eventsPopupToggle');
        const closeEventsPopup = document.getElementById('closeEventsPopup');
        const eventsPopupDisableToggle = document.getElementById('eventsPopupDisableToggle');

        // persistent user preference to enable/disable popups (default: enabled)
        let popupsEnabled = (() => {
            const v = localStorage.getItem('popupsEnabled');
            return v === null ? true : v !== 'false';
        })();

        function setPopupsEnabled(enabled) {
            popupsEnabled = !!enabled;
            localStorage.setItem('popupsEnabled', popupsEnabled);
            if (eventsPopupDisableToggle) {
                eventsPopupDisableToggle.setAttribute('aria-pressed', String(!popupsEnabled));
                eventsPopupDisableToggle.title = popupsEnabled ? 'Disable pop-up events' : 'Enable pop-up events';
            }
            if (eventsPopupToggle) {
                if (!popupsEnabled) eventsPopupToggle.classList.add('disabled'); else eventsPopupToggle.classList.remove('disabled');
            }
            // if disabling, hide the popup if open
            if (!popupsEnabled && eventsPopup && !eventsPopup.classList.contains('hidden')) {
                if (eventsPopup.contains(document.activeElement) && eventsPopupToggle) eventsPopupToggle.focus();
                if ('inert' in HTMLElement.prototype) eventsPopup.inert = true; else eventsPopup.setAttribute('inert','');
                eventsPopup.classList.add('hidden');
                eventsPopup.setAttribute('aria-hidden', 'true');
                if (eventsPopupToggle) eventsPopupToggle.setAttribute('aria-expanded', 'false');
            }

            // Show a small toast to indicate the new state
            if (popupsEnabled) {
                showToast('Pop-ups enabled', 'success');
            } else {
                showToast('Pop-ups disabled', 'error');
            }
        }

        if (eventsPopupDisableToggle) {
            eventsPopupDisableToggle.addEventListener('click', () => {
                setPopupsEnabled(!popupsEnabled);
            });
            // initialize UI state
            setPopupsEnabled(popupsEnabled);
        }

        // Only show lifecycle events (created / added / stopped / restarted) — include reconnect attempts in UI
        function isLifecycleEvent(msg) {
            if (!msg || typeof msg !== 'string') return false;
            const lower = msg.toLowerCase();

            // If the line explicitly mentions "reconnect attempt" show it (user requested)
            if (/\breconnect attempt\b/i.test(lower)) return true;

            // Ignore pure transient countdown lines (e.g., "retrying in 10s")
            const transientRegex = /\b(retry in|retrying in|\d+\s*second|\d+\s*sec|soniyadan|soniya)\b/i;
            if (transientRegex.test(lower)) return false;

            // Positive lifecycle keywords (success states and reconnect)
            return /\b(created|added|started|joined|serverga|serverga qo|serverga ulandi|stopped|exited|restarted|restarting|restart|reconnect)\b/i.test(lower);
        }

        function getLifecycleType(msg) {
            const lower = (msg||'').toLowerCase();
            if (/\b(created|added)\b/.test(lower)) return 'added';
            if (/\b(stopped|exited)\b/.test(lower)) return 'stopped';
            if (/\b(restarted|restarting|restart)\b/.test(lower)) return 'restarted';
            if (/\b(reconnect attempt|reconnect)\b/.test(lower)) return 'reconnect';
            if (/\b(started|joined|serverga|serverga ulandi|serverga qo)\b/.test(lower)) return 'started';
            return 'info';
        }

        // Normalize event lines for display and dedupe
        function normalizeEventLine(line) {
            if (!line) return '';
            // remove leading timestamp and level: [ISO] [level]
            let s = String(line).replace(/^\[.*?\]\s*\[.*?\]\s*/, '').trim();
            // Normalize common phrases
            s = s.replace(/Process exited with code\s+\w+/i, 'Process exited');
            s = s.replace(/\s+\-\s+/, ' - ');
            return s;
        }

        function showEventsPopup(msg, opts = {}) {
            if (!eventsPopup || !eventsPopupList) return;
            // Respect user's popup preference
            if (!popupsEnabled) return;
            // Only show lifecycle events in the popup per user request
            if (!isLifecycleEvent(msg)) return;

            const type = getLifecycleType(msg);
            const item = document.createElement('div');
            item.className = `events-popup-item event-type-${type}`;
            item.tabIndex = -1; // make focusable programmatically

            // Build a cleaner, professional inner markup
            const iconHTML = type === 'added' ? '<i class="fa fa-plus-circle"></i>' : (type === 'stopped' ? '<i class="fa fa-stop-circle"></i>' : (type === 'restarted' ? '<i class="fa fa-redo-alt"></i>' : (type === 'reconnect' ? '<i class="fa fa-exclamation-triangle"></i>' : '<i class="fa fa-server"></i>')));
            const shortTitle = type === 'added' ? 'Added' : (type === 'stopped' ? 'Stopped' : (type === 'restarted' ? 'Restarted' : (type === 'reconnect' ? 'Reconnect' : 'Info')));

            const content = document.createElement('div');
            content.className = 'events-popup-item-inner';
            content.innerHTML = `
                <div class="event-icon">${iconHTML}</div>
                <div class="event-body">
                    <div class="event-title">${shortTitle}</div>
                    <div class="event-text">${opts.noTimestamp ? escapeHTML(msg) : escapeHTML(new Date().toLocaleTimeString() + ' — ' + msg)}</div>
                </div>
            `;

            item.appendChild(content);
            eventsPopupList.insertBefore(item, eventsPopupList.firstChild);

            // Show popup and adjust accessibility attributes
            if ('inert' in HTMLElement.prototype) eventsPopup.inert = false; else eventsPopup.removeAttribute('inert');
            eventsPopup.classList.remove('hidden');
            eventsPopup.setAttribute('aria-hidden', 'false');
            if (eventsPopupToggle) eventsPopupToggle.setAttribute('aria-expanded', 'true');

            // focus the newly added item for screen readers/users
            try { item.focus(); } catch (e) {}

            // briefly flash the toggle button
            if (eventsPopupToggle) {
                eventsPopupToggle.classList.add('new-event');
                setTimeout(() => eventsPopupToggle.classList.remove('new-event'), 3000);
            }
        }

        // Replace old behavior: we only show lifecycle events and do not show other errors in popup

        if (eventsPopupToggle) eventsPopupToggle.addEventListener('click', () => {
            if (!eventsPopup) return;
            const willHide = !eventsPopup.classList.contains('hidden');
            if (willHide) {
                // if focus is inside popup, move it to toggle before hiding
                if (eventsPopup.contains(document.activeElement) && eventsPopupToggle) eventsPopupToggle.focus();
                // set inert and hide
                if ('inert' in HTMLElement.prototype) eventsPopup.inert = true; else eventsPopup.setAttribute('inert','');
                eventsPopup.classList.add('hidden');
                eventsPopup.setAttribute('aria-hidden', 'true');
                if (eventsPopupToggle) eventsPopupToggle.setAttribute('aria-expanded', 'false');
            } else {
                // show
                if ('inert' in HTMLElement.prototype) eventsPopup.inert = false; else eventsPopup.removeAttribute('inert');
                eventsPopup.classList.remove('hidden');
                eventsPopup.setAttribute('aria-hidden', 'false');
                if (eventsPopupToggle) eventsPopupToggle.setAttribute('aria-expanded', 'true');
                // focus the first item or close button
                const first = eventsPopup.querySelector('.events-popup-item');
                if (first) try { first.focus(); } catch (e) {} else if (closeEventsPopup) closeEventsPopup.focus();
            }
        });
        if (closeEventsPopup) closeEventsPopup.addEventListener('click', () => {
            if (!eventsPopup) return;
            // if closing while inner element is focused, move focus to toggle
            if (eventsPopup.contains(document.activeElement) && eventsPopupToggle) eventsPopupToggle.focus();
            if ('inert' in HTMLElement.prototype) eventsPopup.inert = true; else eventsPopup.setAttribute('inert','');
            eventsPopup.classList.add('hidden');
            eventsPopup.setAttribute('aria-hidden', 'true');
            if (eventsPopupToggle) eventsPopupToggle.setAttribute('aria-expanded', 'false');
        });

        // Global events polling (simple popup even when no server is selected)
        async function fetchAndRenderGlobalEvents() {
            try {
                const token = localStorage.getItem('token');
                const res = await fetch(`/api/events?lines=20`, { headers: { 'Authorization': `Bearer ${token}` } });
                if (!res.ok) return;
                const j = await res.json();
                const text = (j.events && j.events.trim()) ? j.events : '';
                const lines = text.split(/\r?\n/).filter(Boolean);
                // find last lifecycle event line across global events and normalize/dedupe
                let lastLifecycle = '';
                for (let i = lines.length - 1; i >= 0; i--) {
                    if (isLifecycleEvent(lines[i])) { lastLifecycle = normalizeEventLine(lines[i].replace(/^.*?:\s*/, '')); break; }
                }
                if (lastLifecycle && lastLifecycle !== lastSeenEvent) {
                    lastSeenEvent = lastLifecycle;
                    showEventsPopup(lastLifecycle, { noTimestamp: true });
                }
            } catch (e) {
                // ignore fetch errors silently per user preference
            }
        }

        // Start global polling every 3s
        setInterval(fetchAndRenderGlobalEvents, 3000);
        // Run once immediately
        fetchAndRenderGlobalEvents();

        if (logSelect) {
            logSelect.addEventListener('change', (e) => {
                const id = e.target.value;
                clearLogPoll();
                clearEventsPoll();
                fetchAndRenderLogs(id);
                fetchAndRenderEvents(id);
                if (id) {
                    logPollInterval = setInterval(() => fetchAndRenderLogs(id), 2000);
                    eventsPollInterval = setInterval(() => fetchAndRenderEvents(id), 2000);
                }
            });
        }

        if (downloadBtn) {
            downloadBtn.addEventListener('click', async () => {
                const id = logSelect.value;
                if (!id) return alert('Select a server first');
                const token = localStorage.getItem('token');
                try {
                    const res = await fetch(`/api/projects/${id}/logs?lines=10000`, { headers: { 'Authorization': `Bearer ${token}` } });
                    if (!res.ok) return alert('Failed to download logs');
                    const j = await res.json();
                    const blob = new Blob([j.log || ''], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${id}-logs.txt`;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    URL.revokeObjectURL(url);
                } catch (err) {
                    alert('Download failed: ' + err.message);
                }
            });
        }

        if (downloadEventsBtn) {
            downloadEventsBtn.addEventListener('click', async () => {
                const id = logSelect.value;
                if (!id) return alert('Select a server first');
                const token = localStorage.getItem('token');
                try {
                    const res = await fetch(`/api/projects/${id}/events?lines=10000`, { headers: { 'Authorization': `Bearer ${token}` } });
                    if (!res.ok) return alert('Failed to download events');
                    const j = await res.json();
                    const blob = new Blob([j.events || ''], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${id}-events.txt`;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    URL.revokeObjectURL(url);
                } catch (err) {
                    alert('Download failed: ' + err.message);
                }
            });
        }

    async function startServer(serverId) {
        try {
            const token = localStorage.getItem('token');
            const response = await fetch(`/api/projects/${serverId}/start`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });
            
            const data = await response.json();
            
            if (data.success) {
                showToast('Server started successfully!', 'success');
                updateServerStatus(serverId, 'running');
            } else {
                showToast(data.error || 'Failed to start server', 'error');
            }
        } catch (error) {
            console.error('Error starting server:', error);
            showToast('Failed to start server. Please try again.', 'error');
        }
    }

    async function stopServer(serverId) {
        try {
            const token = localStorage.getItem('token');
            const response = await fetch(`/api/projects/${serverId}/stop`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });
            
            const data = await response.json();
            
            if (data.success) {
                showToast('Server stopped successfully!', 'success');
                updateServerStatus(serverId, 'stopped');
            } else {
                showToast(data.error || 'Failed to stop server', 'error');
            }
        } catch (error) {
            console.error('Error stopping server:', error);
            showToast('Failed to stop server. Please try again.', 'error');
        }
    }

    async function deleteServer(serverId) {
        if (!confirm('Are you sure you want to delete this server?')) return;
        
        try {
            const token = localStorage.getItem('token');
            const response = await fetch(`/api/projects/${serverId}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });
            
            const data = await response.json();
            
            if (data.success) {
                showToast('Server deleted successfully!', 'success');
                document.getElementById(`server-${serverId}`).remove();
                
                // Agar serverlar qolmagan bo'lsa, empty state ko'rsatish
                if (document.querySelectorAll('.server-card').length === 0) {
                    document.getElementById('serverList').innerHTML = `
                        <div class="empty-state">
                            <img src="assets/empty-server.png" alt="No servers" class="empty-icon">
                            <h2>No Minecraft Servers</h2>
                            <p>You don't have any servers yet. Click the button below to create your first server.</p>
                            <button class="btn primary-btn" onclick="window.location.href='/create'">
                                Create First Server
                            </button>
                        </div>
                    `;
                }
            } else {
                showToast(data.error || 'Failed to delete server', 'error');
            }
        } catch (error) {
            console.error('Error deleting server:', error);
            showToast('Failed to delete server. Please try again.', 'error');
        }
    }

    function updateServerStatus(serverId, status) {
        const serverCard = document.getElementById(`server-${serverId}`);
        if (!serverCard) return;
        
        const statusElement = serverCard.querySelector('.server-status');
        const startBtn = serverCard.querySelector('.start-btn');
        const stopBtn = serverCard.querySelector('.stop-btn');
        
        // Statusni yangilash
        statusElement.classList.remove('status-running', 'status-stopped');
        statusElement.classList.add(`status-${status}`);
        
        // Update status element without using innerHTML
        statusElement.innerHTML = '';
        const ind = document.createElement('span');
        ind.className = 'status-indicator';
        statusElement.appendChild(ind);
        statusElement.appendChild(document.createTextNode(' ' + (status === 'running' ? 'Running' : 'Stopped')));
        
        // Tugmalarni yangilash
        startBtn.disabled = status === 'running';
        stopBtn.disabled = status === 'stopped';
    }

    function showToast(message, type) {
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        document.body.appendChild(toast);
        
        setTimeout(() => {
            toast.classList.add('fade-out');
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }

    // Expose control functions to global scope for inline onclick handlers
    window.startServer = startServer;
    window.stopServer = stopServer;
    window.deleteServer = deleteServer;

    // Wire up the logout button to clear auth token and redirect to login
    const logoutBtn = document.getElementById('logoutBtn');
    if (logoutBtn) {
        logoutBtn.addEventListener('click', () => {
            // client-side logout: remove token and go to login
            localStorage.removeItem('token');
            window.location.href = '/auth/login.html';
        });
    }

    // Close DOMContentLoaded listener
    });
</script>
</body>
</html>